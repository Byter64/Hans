// Code generated by Icestudio 0.11.0-rc2

`default_nettype none

//---- Top entity
module main (
 input v220546,
 input [31:0] vdd480d,
 input vf0d699,
 input v56d294,
 input vc07348,
 output [31:0] v1051dc,
 output v020d04,
 output ve225ed,
 output [2:0] vd97cbd,
 output vad115f,
 output v93ff5b,
 output v7bdb16,
 output [4:0] v6969f3
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:31] w3;
 wire [0:2] w4;
 wire [0:31] w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:7] w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:7] w18;
 wire [0:31] w19;
 wire w20;
 wire w21;
 wire [0:4] w22;
 assign w0 = vc07348;
 assign w1 = v56d294;
 assign w2 = vc07348;
 assign v1051dc = w3;
 assign vd97cbd = w4;
 assign w5 = vdd480d;
 assign w6 = vf0d699;
 assign v7bdb16 = w7;
 assign vad115f = w8;
 assign v93ff5b = w9;
 assign ve225ed = w14;
 assign v020d04 = w15;
 assign w20 = v220546;
 assign w21 = v220546;
 assign v6969f3 = w22;
 assign w2 = w0;
 assign w21 = w20;
 v1b8ab9 v3b721a (
  .v40a1f3(w0),
  .v4a7db4(w1),
  .v3bdd73(w7),
  .v914c53(w8),
  .v4ed923(w9),
  .v344e7e(w10),
  .v9bdbf2(w11),
  .v54fa54(w12),
  .v038643(w13),
  .vf6e143(w16),
  .v06bc6b(w17),
  .vf009ec(w18),
  .v3e4bfa(w19),
  .va509f1(w21),
  .vbc59c8(w22)
 );
 vc4dd08 v9522c6 (
  .v608bd9(w17)
 );
 main_vd79216 vd79216 (
  .din(w18)
 );
 main_v911a4a v911a4a (
  .Clock(w2),
  .Daten(w3),
  .zustand(w4),
  .Adresse(w5),
  .Lesen(w6),
  .dout(w10),
  .byte_available(w11),
  .egal(w12),
  .ready(w13),
  .Busy(w14),
  .Fertig(w15),
  .rd(w16),
  .sektorAdresse(w19),
  .Reset(w20)
 );
endmodule

//---- Top entity
module v1b8ab9 (
 input v4a7db4,
 input vf6e143,
 input v06bc6b,
 input [7:0] vf009ec,
 input va509f1,
 input [31:0] v3e4bfa,
 input v40a1f3,
 output v914c53,
 output v4ed923,
 output v3bdd73,
 output [7:0] v344e7e,
 output v9bdbf2,
 output v54fa54,
 output v038643,
 output [4:0] vbc59c8
);
 wire w0;
 wire [0:31] w1;
 wire w2;
 wire [0:7] w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:7] w10;
 wire w11;
 wire w12;
 wire w13;
 wire [0:4] w14;
 assign w0 = v40a1f3;
 assign w1 = v3e4bfa;
 assign w2 = va509f1;
 assign w3 = vf009ec;
 assign w4 = v06bc6b;
 assign w5 = vf6e143;
 assign w6 = v4a7db4;
 assign v914c53 = w7;
 assign v4ed923 = w8;
 assign v3bdd73 = w9;
 assign v344e7e = w10;
 assign v9bdbf2 = w11;
 assign v54fa54 = w12;
 assign v038643 = w13;
 assign vbc59c8 = w14;
 v1b8ab9_v507bb2 v507bb2 (
  .clk(w0),
  .address(w1),
  .reset(w2),
  .din(w3),
  .wr(w4),
  .rd(w5),
  .miso(w6),
  .cs(w7),
  .mosi(w8),
  .sclk(w9),
  .dout(w10),
  .byte_available(w11),
  .ready_for_next_byte(w12),
  .ready(w13),
  .status(w14)
 );
endmodule


module v1b8ab9_v507bb2 (
 input miso,
 input rd,
 input wr,
 input [7:0] din,
 input reset,
 input [31:0] address,
 input clk,
 output cs,
 output mosi,
 output sclk,
 output [7:0] dout,
 output byte_available,
 output ready_for_next_byte,
 output ready,
 output [4:0] status
);
 /* SD Card controller module. Allows reading from and writing to a microSD card
 through SPI mode.
 taken from: https://web.mit.edu/6.111/volume2/www/f2019/tools/sd_controller.v
  */
 
 reg cs; // Connect to SD_DAT[3].
 reg [7:0] dout; // Data output for READ operation. [0-7]
 reg byte_available; // A new byte has been presented on [dout].
 reg ready_for_next_byte; // A new byte should be presented on [din].
 
 
     parameter RST = 0;
     parameter INIT = 1;
     parameter CMD0 = 2;
     parameter CMD55 = 3;
     parameter CMD41 = 4;
     parameter POLL_CMD = 5;
     
     parameter IDLE = 6;
     parameter READ_BLOCK = 7;
     parameter READ_BLOCK_WAIT = 8;
     parameter READ_BLOCK_DATA = 9;
     parameter READ_BLOCK_CRC = 10;
     parameter SEND_CMD = 11;
     parameter RECEIVE_BYTE_WAIT = 12;
     parameter RECEIVE_BYTE = 13;
     parameter WRITE_BLOCK_CMD = 14;
     parameter WRITE_BLOCK_INIT = 15;
     parameter WRITE_BLOCK_DATA = 16;
     parameter WRITE_BLOCK_BYTE = 17;
     parameter WRITE_BLOCK_WAIT = 18;
     
     parameter WRITE_DATA_SIZE = 515;
     
     reg [4:0] state = RST;
     assign status = state;
     reg [4:0] return_state;
     reg sclk_sig = 0;
     reg [55:0] cmd_out;
     reg [7:0] recv_data;
     reg cmd_mode = 1;
     reg [7:0] data_sig = 8'hFF;
     
     reg [9:0] byte_counter;
     reg [9:0] bit_counter;
     
     reg [26:0] boot_counter = 27'd100_000_000;
     always @(posedge clk) begin
         if(reset == 1) begin
             state <= RST;
             sclk_sig <= 0;
             boot_counter <= 27'd100_000_000;
         end
         else begin
             case(state)
                 RST: begin
                     if(boot_counter == 0) begin
                         sclk_sig <= 0;
                         cmd_out <= {56{1'b1}};
                         byte_counter <= 0;
                         byte_available <= 0;
                         ready_for_next_byte <= 0;
                         cmd_mode <= 1;
                         bit_counter <= 160;
                         cs <= 1;
                         state <= INIT;
                     end
                     else begin
                         boot_counter <= boot_counter - 1;
                     end
                 end
                 INIT: begin
                     if(bit_counter == 0) begin
                         cs <= 0;
                         state <= CMD0;
                     end
                     else begin
                         bit_counter <= bit_counter - 1;
                         sclk_sig <= ~sclk_sig;
                     end
                 end
                 CMD0: begin
                     cmd_out <= 56'hFF_40_00_00_00_00_95;
                     bit_counter <= 55;
                     return_state <= CMD55;
                     state <= SEND_CMD;
                 end
                 CMD55: begin
                     cmd_out <= 56'hFF_77_00_00_00_00_01;
                     bit_counter <= 55;
                     return_state <= CMD41;
                     state <= SEND_CMD;
                 end
                 CMD41: begin
                     cmd_out <= 56'hFF_69_00_00_00_00_01;
                     bit_counter <= 55;
                     return_state <= POLL_CMD;
                     state <= SEND_CMD;
                 end
                 POLL_CMD: begin
                     if(recv_data[0] == 0) begin
                         state <= IDLE;
                     end
                     else begin
                         state <= CMD55;
                     end
                 end
                 IDLE: begin
                     if(rd == 1) begin
                         state <= READ_BLOCK;
                     end
                     else if(wr == 1) begin
                         state <= WRITE_BLOCK_CMD;
                     end
                     else begin
                         state <= IDLE;
                     end
                 end
                 READ_BLOCK: begin
                     cmd_out <= {16'hFF_51, address, 8'hFF};
                     bit_counter <= 55;
                     return_state <= READ_BLOCK_WAIT;
                     state <= SEND_CMD;
                 end
                 READ_BLOCK_WAIT: begin
                     if(sclk_sig == 1 && miso == 0) begin
                         byte_counter <= 511;
                         bit_counter <= 7;
                         return_state <= READ_BLOCK_DATA;
                         state <= RECEIVE_BYTE;
                     end
                     sclk_sig <= ~sclk_sig;
                 end
                 READ_BLOCK_DATA: begin
                     dout <= recv_data;
                     byte_available <= 1;
                     if (byte_counter == 0) begin
                         bit_counter <= 7;
                         return_state <= READ_BLOCK_CRC;
                         state <= RECEIVE_BYTE;
                     end
                     else begin
                         byte_counter <= byte_counter - 1;
                         return_state <= READ_BLOCK_DATA;
                         bit_counter <= 7;
                         state <= RECEIVE_BYTE;
                     end
                 end
                 READ_BLOCK_CRC: begin
                     bit_counter <= 7;
                     return_state <= IDLE;
                     state <= RECEIVE_BYTE;
                 end
                 SEND_CMD: begin
                     if (sclk_sig == 1) begin
                         if (bit_counter == 0) begin
                             state <= RECEIVE_BYTE_WAIT;
                         end
                         else begin
                             bit_counter <= bit_counter - 1;
                             cmd_out <= {cmd_out[54:0], 1'b1};
                         end
                     end
                     sclk_sig <= ~sclk_sig;
                 end
                 RECEIVE_BYTE_WAIT: begin
                     if (sclk_sig == 1) begin
                         if (miso == 0) begin
                             recv_data <= 0;
                             bit_counter <= 6;
                             state <= RECEIVE_BYTE;
                         end
                     end
                     sclk_sig <= ~sclk_sig;
                 end
                 RECEIVE_BYTE: begin
                     byte_available <= 0;
                     if (sclk_sig == 1) begin
                         recv_data <= {recv_data[6:0], miso};
                         if (bit_counter == 0) begin
                             state <= return_state;
                         end
                         else begin
                             bit_counter <= bit_counter - 1;
                         end
                     end
                     sclk_sig <= ~sclk_sig;
                 end
                 WRITE_BLOCK_CMD: begin
                     cmd_out <= {16'hFF_58, address, 8'hFF};
                     bit_counter <= 55;
                     return_state <= WRITE_BLOCK_INIT;
                     state <= SEND_CMD;
 		    ready_for_next_byte <= 1;
                 end
                 WRITE_BLOCK_INIT: begin
                     cmd_mode <= 0;
                     byte_counter <= WRITE_DATA_SIZE; 
                     state <= WRITE_BLOCK_DATA;
                     ready_for_next_byte <= 0;
                 end
                 WRITE_BLOCK_DATA: begin
                     if (byte_counter == 0) begin
                         state <= RECEIVE_BYTE_WAIT;
                         return_state <= WRITE_BLOCK_WAIT;
                     end
                     else begin
                         if ((byte_counter == 2) || (byte_counter == 1)) begin
                             data_sig <= 8'hFF;
                         end
                         else if (byte_counter == WRITE_DATA_SIZE) begin
                             data_sig <= 8'hFE;
                         end
                         else begin
                             data_sig <= din;
                             ready_for_next_byte <= 1;
                         end
                         bit_counter <= 7;
                         state <= WRITE_BLOCK_BYTE;
                         byte_counter <= byte_counter - 1;
                     end
                 end
                 WRITE_BLOCK_BYTE: begin
                     if (sclk_sig == 1) begin
                         if (bit_counter == 0) begin
                             state <= WRITE_BLOCK_DATA;
                             ready_for_next_byte <= 0;
                         end
                         else begin
                             data_sig <= {data_sig[6:0], 1'b1};
                             bit_counter <= bit_counter - 1;
                         end;
                     end;
                     sclk_sig <= ~sclk_sig;
                 end
                 WRITE_BLOCK_WAIT: begin
                     if (sclk_sig == 1) begin
                         if (miso == 1) begin
                             state <= IDLE;
                             cmd_mode <= 1;
                         end
                     end
                     sclk_sig = ~sclk_sig;
                 end
             endcase
         end
     end
 
     assign sclk = sclk_sig;
     assign mosi = cmd_mode ? cmd_out[55] : data_sig[7];
     assign ready = (state == IDLE);
endmodule
//---- Top entity
module vc4dd08 (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 vc4dd08_v68c173 v68c173 (
  .v(w0)
 );
endmodule

//---------------------------------------------------
//-- Bit 0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Assign 0 to the output wire
//---------------------------------------------------

module vc4dd08_v68c173 (
 output v
);
 // Bit 0
 
 assign v = 1'b0;
endmodule

module main_vd79216 (
 output [7:0] din
);
 reg din = 8'b0;
endmodule

module main_v911a4a (
 input Clock,
 input Reset,
 input [31:0] Adresse,
 input Lesen,
 input [7:0] dout,
 input byte_available,
 input ready,
 input egal,
 output [31:0] Daten,
 output Fertig,
 output Busy,
 output [2:0] zustand,
 output rd,
 output [31:0] sektorAdresse
);
 reg [31:0] Daten; //Gelesene Daten. Ist erst gültig, wenn [Fertig] oben ist
 reg Fertig; //Daten an [Daten] sind gültig
 reg Busy; //Wenn oben, können Leseanfragen über [Lesen] gesendet werden
 
 
     // Zustandsdefinitionen für den SD-Controller
     localparam INITIALISIEREN = 3'd0;
     localparam IDLE = 3'd1;
     localparam BYTE1 = 3'd2;
     localparam BYTE2 = 3'd3;
     localparam BYTE3 = 3'd4;
     localparam BYTE4 = 3'd5;
     localparam SEKTORFERTIGLESEN = 3'd6;
 
     // SD CARD INPUTS/OUTPUTS
     reg rd = 0; // Read signal for SD card
     wire [31:0] sektorAdresse;
     reg [2:0] state = IDLE;
     reg [8:0] byteZaehler = 0;
 
     assign zustand = state;
     assign sektorAdresse = {Adresse[29:6], 8'b0}; 
     //Adresse wird von 8-Bit auf 32-Bit Bytes konvertiert, für Sektoradresse werden die ersten 9 Bits ignoriert
 
 
     always @(posedge Clock or posedge Reset) begin
         if(Reset)
             byteZaehler <= 0;
         else begin
             if((state != IDLE) && byte_available)
                 byteZaehler <= byteZaehler + 1;
             else if (state == IDLE) begin
                 byteZaehler <= 0;
             end
         end
 
     end
 
     // Zustandsautomat für den SD-Controller
     always @(posedge Clock) begin
         if (Reset) begin
             Daten <= 0;
             Fertig <= 0;
             state <= INITIALISIEREN;
             rd <= 0;
             Busy <= 1;
         end else begin
             case (state)
                 INITIALISIEREN:begin
                     Busy <= 1;
                     if(ready) begin
                         state = IDLE;
                     end
                 end
                 IDLE: begin
                     Busy <= 0;
                     if (Lesen && ready) begin
                         state <= BYTE1;
                         Busy <= 1;
                         rd <= 1;
                     end
                 end
                 BYTE1: begin
                     Busy <= 1;
                     if (byteZaehler == (Adresse[6:0] << 2) && byte_available) begin
                         Daten[31:24] <= dout;
                         state <= BYTE2;
                     end
                 end
                 BYTE2: begin
                     Busy <= 1;
                     if (byte_available) begin
                         Daten[23:16] <= dout;
                         state <= BYTE3;
                     end
                 end
                 BYTE3: begin
                     Busy <= 1;
                     if (byte_available) begin
                         Daten[15:8] <= dout;
                         state <= BYTE4;
                     end
                 end
                 BYTE4: begin
                     Busy <= 1;
                     if (byte_available) begin
                         Daten[7:0] <= dout;
                         rd <= 0;
                         Fertig <= 1;
                         state <= SEKTORFERTIGLESEN;
                     end
                 end
                 SEKTORFERTIGLESEN: begin
                     if(byteZaehler == 9'd0) begin
                         Busy <= 0;
                         state <= IDLE;
                         rd <= 0;
                         Fertig <= 0;
                     end
                 end
                 default: state <= IDLE;
             endcase
         end
     end
 
endmodule
